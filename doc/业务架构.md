
---
# 业务需求

#### 聊天窗口（群聊）模式
- **聊天窗口** = 群聊房间，客户固定，客服可进可出
- **消息** = 群聊消息，所有在线成员都能看到
- **历史记录** = 跟随窗口，客户重新上线进入原窗口
---
---
# 总体方案的核心思想（一句话概括）

先分配“序号”（服务器端的 sequence）,再把消息写入服务端存储，再发 push 通知客户端；客户端收到通知后拉取增量数据（按照服务端序号拉），服务器端以存储为真相并用中心化的序号服务保证顺序。这样就避开了使用 MQ 来保证整体的顺序性。

核心意思就是把「存储层当作双方的桥梁（真相）」：服务端先把消息写进持久存储并分配序号，随后给目标端一个“有新消息/请拉取”的通知；客户端收到通知后按序号去拉取真正的消息内容并做去重/确认。用通俗话说就是 “先存后推，客户端按序拉（push-notify + pull）”，而不是单纯依赖 MQ 的传输顺序来决定最终显示顺序。

当服务端的方法不是void的时候，响应消息是直接通过自研的websocket springmvc调用WebSocketSession推送给客户端的，没有走自研框架的消息分发机制，因为本身websocket是没有响应这个概念的，不是说这个返回回来的请求对应的是当初发送出去的哪个请求，因此在响应回去的时候，方法的返回对象只能是我们自己定义的带有路由信息的对象，不能是纯粹的业务数据返回，也就是自定义的纯粹的业务数据，都是直接使用服务端上持有的WebSocketSession直接响应的

---

## 1. 谁给消息打序号（serverMsgId）

微信做法：有一个统一的序号服务（seqsvr），每一类需要同步的数据（比如消息、会话状态）都会向 seqsvr 申请一个递增的序号（通常是按用户或按某维度的序列空间），这个序号作为版本号/排序依据。这样客户端用这个序号就能按顺序拉增量，不需要依赖消息队列的 offset。

---

## 2. 先写存储，再推通知（push-pull）

微信普遍采用写存储 + push 通知 + 客户端拉取的模式：消息先落到接收方的服务器存储（server-side store），服务器向接收端发一个通知（push/长连接推送或系统通知），客户端接到通知再主动从服务端拉取真正的消息数据（用上面那个序号来拉增量）。这种方式把可靠性（不丢）和移动端弱网容忍放在第一位。

**为什么这样解决顺序问题**：

* 存储是“真相”，只要把消息以正确序号写到存储里，客户端按序号拉取即可保证显示顺序；
* 即便通知乱序或丢失，客户端只要按序号拉取就能补全且按序显示。

---

## 3. 消息处理的职责分离与抗峰值（灰度）

微信在大规模场景下把接入层、逻辑层、存储层分开，消息流经这些层时，每一层都有明确职责：鉴权/连接在接入层，业务逻辑（包括序号分配/路由）在逻辑层，最终消息落库在存储层。运维上还有成熟的流控/过载保护来避免洪峰时系统崩溃。

---

## 4. 多设备 / 离线 / 重连 的处理

微信客户端在重连时会带上已同步的最大序号，服务端会根据序号给出增量（差量同步），保证不重复也不丢失。多个设备/多端同步也用同样的序号体系协调。

---

# 整体业务流程（客户视角与客服视角）

### 客户视角

* 客户点击商城的聊天按钮，系统先从 DB 获取这个用户当前有哪些聊天窗口；
* 每个聊天窗口都有“最后看到的全局 id”，客户端根据这个 id 去 MySQL 拉取数据；

  * 如果有大于这个 id 的消息就加载这些新消息，
  * 如果没有大于这个 id 的，则拉取最近十条数据（分页查询）；
* 拉取到消息后，前端要做好未读提醒；全局 id 的生成方案在系统内统一确定。
* 群聊加入一个新的客服时，先去 MySQL 拉取最后十条；往上翻才去分页查询，由 MySQL 负责序列化。

### 客服视角

* 客服登录账号后，看到系统分配给他的聊天窗口列表，并能拉取客户信息。

---

# 基础设施与职责（一句话说明每个组件做什么）

* **Nacos**：负责监听 mall-chat 实例的 IP 地址（谁还活着、在哪里）。
* **Redis**：维护客户端 WebSocket 的 session id 与对应实例 IP 的映射；客户端建立连接时把 session id 和当前实例 IP 写入 Redis，离线时立即删除。Redis 还做用户-实例映射和未读计数等热数据，支持基于userId的推送。
* **MySQL**：保存所有聊天记录和已读指针，作为“真相库”；按 conversation 做范围查询与拉最新 N 条 非常友好，conversation_id 包含分片键，后续可以做分库分表。
* **Elasticsearch（ES）**：保存可搜索的消息副本，承担全文、中文分词与高亮搜索功能。
* **对象存储（MinIO/S3）**：存放图片、视频和大附件，消息里只保存 URL。
* **mall-chat 实例**：维护浏览器的长连接、把 sessionId→instanceId 写 Redis、通过服务器间 WebSocket 连接推送消息，把"去拉取"的通知下发给用户。
* **Processor（或由 mall-chat 本机承担）**：收到消息后做幂等检查、分配会话内的 server_msg_id、写 MySQL、并通过服务器间 WebSocket 连接推送轻通知（支持重试机制）。

---

# 端到端简洁流程（你可以直接读给产品/开发）

1. 浏览器建立 WebSocket 并把 session 写到 Redis；离线立即删除。
2. 客户发消息，消息包含 conversationId，系统分配全局有序的 id（server_msg_id）,然后消息持久化到 MySQL.
3. 如果有客服在线，系统分配给售前客服或推送给现有群成员（基于userId推送，支持重试）。
4. 系统通过服务器间 WebSocket 连接推送轻通知，支持 Nacos 配置的重试策略（包括 sessionId 变化后的重试）。
5. 目标用户在线时直接通过 WebSocket 推"请拉取"的轻提示给客户端；离线时消息存储在数据库，用户重连后主动拉取。
6. 客户端收到提示后，立刻向后端发请求，从 MySQL 拉取该会话的新消息并展示。
7. 同时后台把消息同步到 ES，供搜索使用（MySQL 是真相，ES 是搜索）。

---

# 要特别注意的几件事（给产品/测试/运维的要点）

* **幂等性**：用 `conversationId + clientMsgId` 做幂等保护，通知投递与索引写入都要可重试且不重复生效。
* **通知可靠**：通知通过服务器间 WebSocket 连接推送，支持 Nacos 配置的重试策略，不要只靠内存广播或一次性 HTTP。
* **重连与补偿**：客户端用最后看到的 server_msg_id 拉增量；收件箱里的通知若长时间未处理，要有补偿或转交机制。
* **搜索一致性**：ES 索引是近实时的，搜索可能存在短暂延迟；出现索引失败要有重试与全量重建手段。
* **分片与扩展**：conversation_id 里包含分片键，后续可做分库分表，避免单库成为瓶颈。
* **附件处理**：大文件走对象存储，消息里只保留 URL 和元数据。

---



下面是把你发的整段技术细节做的**润色整理版**。我尽量**不改原意**、保留你的注释与结构，只做语言上顺畅化和格式统一，便于直接拿去当文档或交给同事阅读。若你要我**严格一字不改**的原稿也能给，但你之前也说“需要润笔”，所以这是润过的版本。

# 电商客服系统微信式消息模型技术方案（整理版）

## 5. 方案概述

微信式消息模型 — 核心原则

### 消息顺序保证

* **分配 serverMsgId**：先分配 serverMsgId，再去插入 DB。接受 serverMsgId 产生空洞的可能（跳号、孔洞），这仅意味着未读计数与分页查询不能简单按 id 连续计算。
* **失败消息不占位**：如果插入 DB 失败，该消息不进入全局顺序（对应的 serverMsgId 不会写入消息表），不会影响后续消息，只是产生空洞。
* **严格递增**：serverMsgId 在同一会话窗口内单调递增，保证成功消息的顺序。
* **客户端排序**：客户端按 serverMsgId 排序并展示消息。

### 整体架构

```
客户端(Web/Mobile)发送消息
       │
       ▼
   WebSocket (推送通道)
       │
       ▼
       │
       ├─► （可选）对象存储 (MinIO, 图片/视频/附件)
       | 
       └─► 消息ID生成器 (serverMsgId)
	   |
	   └─► DB (后续做 ES 同步)
```

---

## 6. 消息模型与流转

### 6.1 消息状态管理（服务端/客户端分离）

服务端在 `chat_message.status` 中维护 5 种状态（默认 `PENDING`）：

* **PENDING**：消息已分配 `server_msg_id`并成功写入数据库并，但还没把“去拉/通知”写入目标实例的收件箱（或还没下发给客户端）。
* **PUSHED**：轻通知（写入 `inbox:{instance}` 的 Redis Stream）已写入/交付，表示投递到目标实例的“收件箱”完成，目标实例会负责把“去拉”下发给客户端。
* **DELIVERED**：客户端已从服务端拉取到该消息（客户端 sync 拉取包含此 `server_msg_id`），或客户端已 ACK 到达；表示用户端已经能看到这条消息（到达端）。
* **READ**：用户在客户端确认已读（前端主动上报 `POST /read` 并把 `lastSeenServerMsgId` 提交，若该消息 id ≤ lastSeen 则标记为已读）。
* **FAILED**：写库成功后，在后续投递阶段（写 inbox、推送、或持久化逻辑）确定为终态失败（达到重试上限或触发 DLQ），需要人工或自动补偿。

客户端（前端）本地状态（**仅 JS 本地维护，不写 DB**）：

* **sending**：客户端本地发送中（占位，使用 `clientMsgId`）。
* **failed**：客户端发送失败（如网络问题或服务端返回失败），用户可重发。

当客户端收到来自服务端的确认（包含 `server_msg_id`）时，前端把本地 `sending` → `sent`（或显示“已发送”）；随后根据服务端状态 `DELIVERED/READ` 更新小勾或已读标记。

---

### 6.2 消息流转流程

#### 文字消息流程（简要）

1. 客户端发送消息（带 `clientMsgId`，UI 显示发送中）。
2. 分配 `serverMsgId`（conversation 维度递增）。
3. 写入 DB（插入 `chat_message`）。
4. 通过 WebSocket 推送“轻通知”给目标用户对应实例（目标实例再通知客户端去拉）。
5. 客户端收到确认后更新消息状态并按序拉取展示。

#### 文件消息流程（两步式，对用户透明）

文件上传采用两步式架构，对用户完全透明：

**第一步：HTTP 上传文件**
1. 客户端通过 HTTP/HTTPS 上传文件到 Spring MVC 接口
2. 服务端进行文件类型验证、病毒扫描
3. 上传到 MinIO 对象存储，生成文件 URL 和元数据
4. 返回给客户端：`fileId`、`url`、`size`、`duration`（视频）等

**第二步：WebSocket 发送消息**
1. 客户端收到上传成功后，自动通过 WebSocket 发送消息
2. 消息包含：`fileId`、`url`、缩略图、时长、大小等元数据
3. 服务端分配 `serverMsgId` 并写入数据库
4. 通过 WebSocket 推送给目标用户

**用户体验（一步式）**
- 用户点击发送 → 显示上传进度 → 自动发送消息
- 对方收到消息，点击直接播放/下载
- 整个过程对用户完全透明

**技术优势**
- WebSocket 通道保持轻量、实时
- HTTP 上传稳定、支持断点续传、可走 CDN
- 文件存储与消息传输解耦，便于扩展

#### 失败处理流程

1. 消息发送失败（网络/服务异常），前端显示失败（红色重发按钮）。
2. 用户点击重发 → 重新执行发送流程（重发视为新消息或保留幂等键，见下）。

---

### clientMsgId 的意义与幂等策略

**clientMsgId**（客户端生成）用途：

1. **发送中的占位符**：在消息持久化之前，做 UI 占位（显示“发送中”）。
2. **幂等 & 重发去重**：网络自动重传或断线重连时，必须保留相同的 `clientMsgId` 以保证幂等。仅当用户显式选择“重发为新消息”时才生成新的 `clientMsgId`，否则应重试同一 `clientMsgId`。

**实现细节（要点）**：

* 客户端为每条“逻辑消息”生成长期唯一的 `clientMsgId`（建议格式：`c:<unixms>:<rand>` 或 UUID）。
* 发送失败、超时等情况下客户端自动重试必须带相同 `clientMsgId`，直到收到服务端确认或达到本地重试上限。
* 数据库层对 `(conversation_id, client_msg_id)` 建唯一约束（`UNIQUE (conversation_id, client_msg_id)`）。
* 服务端接到消息时尝试原子插入（写 `server_msg_id` 等字段）并返回 `serverMsgId`；若插入报 DuplicateKey（说明是重传），则直接查出已有记录并返回（包含 `serverMsgId`、status）。
* 对异步消费（若使用 MQ）的场景，同样在消费端用相同唯一约束做幂等跳过。
* 文件类消息阶段用 `fileHash + clientMsgId` 做去重/校验，避免重复上传或重复写库。

---

## 7. 会话 / serverMsgId 策略

### 7.1 聊天窗口（群聊）模式

* **聊天窗口 = 群聊房间**：客户固定，客服可进可出；消息属于窗口（conversation），历史跟随窗口。
* **serverMsgId 按窗口递增**：把 Redis key 改为 `chat:serverMsgId:{conversationId}`（而不是按 userId），窗口内严格单调有序，客户端通过 `lastSeenServerMsgId` 拉取增量历史，多端可见序列一致。

示例：

```java
// 修改前：按用户ID递增
String key = "chat:serverMsgId:" + userId;

// 修改后：按窗口ID递增
String key = "chat:serverMsgId:" + conversationId;
```

---

## 8. 数据库设计（DDL & 索引）

### 聊天窗口表

```sql
CREATE TABLE chat_conversation (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  conversation_id VARCHAR(128) NOT NULL UNIQUE, -- 外部可用 uuid
  customer_id BIGINT NOT NULL,
  agent_id BIGINT NULL  COMMENT '分配的客服座席id',
  status VARCHAR(16) NOT NULL DEFAULT 'active', -- active|closed|waiting
  tenant_id BIGINT NOT NULL DEFAULT 0 COMMENT '多租户标识,亦即商户,记录这个聊天是在哪个店铺发起的',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX (tenant_id, status)
);
```

### 窗口成员表

```sql
CREATE TABLE chat_conversation (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  conversation_id VARCHAR(128) NOT NULL UNIQUE, -- 外部可用 uuid
  customer_id BIGINT NOT NULL,
  agent_id BIGINT NULL  COMMENT '分配的客服座席id',
  status VARCHAR(16) NOT NULL DEFAULT 'active', -- active|closed|waiting
  tenant_id BIGINT NOT NULL DEFAULT 0 COMMENT '多租户标识,亦即商户,记录这个聊天是在哪个店铺发起的',
  shop_id BIGINT NULL COMMENT '店铺ID（可为空）',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX (tenant_id, status),
  INDEX (customer_id, shop_id,status)
);
```

### 聊天消息表

```sql
CREATE TABLE chat_message (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  conversation_id VARCHAR(128) NOT NULL,    -- 包含分片键，例如 "shardKey:convX"
  server_msg_id BIGINT NOT NULL,            -- 会话内递增序号
  client_msg_id VARCHAR(128) NOT NULL,
  sender_id VARCHAR(64) NOT NULL,
  msg_type VARCHAR(32) NOT NULL,
  payload JSON NULL,                        -- 或 TEXT, 根据 MySQL 版本
  hash_code BINARY(32) NULL COMMENT '如果图片或者视频,要有值, raw SHA-256 (32 bytes), 选择 SHA-256 来生成',
  status VARCHAR(16) DEFAULT 'PENDING' COMMENT 'PENDING,PUSHED,DELIVERED,READ,FAILED',
  push_attempts INT DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  delivered_at DATETIME NULL,
  INDEX idx_conv_server (conversation_id, server_msg_id),
  INDEX idx_conv_hash (conversation_id, hash_code),
  UNIQUE KEY uq_conv_client (conversation_id, client_msg_id)
) ENGINE=InnoDB;
```

### 已读指针表

```sql
CREATE TABLE user_conversation_read (
  conversation_id VARCHAR(128) NOT NULL,
  user_id VARCHAR(64) NOT NULL,
  last_read_server_msg_id BIGINT DEFAULT 0,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (conversation_id, user_id),
  INDEX idx_user_read_user (user_id, conversation_id)
) ENGINE=InnoDB;
```

> 注意：`server_msg_id` 在最终设计中建议 **NOT NULL**（分配后写入），以便 `idx_conv_server` 索引能被有效利用。ID 孔洞（跳号）是可接受的，未读/分页逻辑需根据 `>` / `>=` 而非连续性假设来实现。

---

## 9. 消息拉取 / Push 通知 协议（统一 envelope，Spring MVC 风格）

建议用统一 envelope 结构，接口字段与你示例保持一致，方便前端路由到不同 handler。

### WebSocket 消息结构分离

WebSocket通信分为请求和响应两种类型：

#### WebSocketRequest（客户端请求）

客户端向服务端发送的请求消息：

```json
{
  "interface": "sendMessage",           // 接口名称，用于路由
  "version": 1,                        // 协议版本
  "payload": {                         // 具体业务内容
    // 根据interface不同，payload内容不同
  }
}
```

#### WebSocketResponse（服务端响应）

服务端向客户端发送的响应消息：

```json
{
  "interface": "rplySendResult",        // 接口名称，用于路由
  "version": 1,                        // 协议版本
  "success": true,                     // 是否请求成功
  "errorMessage": null,                 // 错误信息 (失败时使用)
  "payload": {                         // 具体业务内容
    // 根据interface不同，payload内容不同
  }
}
```

**字段说明：**
- `interface`: 接口名称，用于Spring MVC风格的路由机制
- `version`: 协议版本，当前为1
- `success`: 是否成功，仅用于WebSocketResponse中
- `errorMessage`: 错误信息，当`success`为`false`时使用，仅用于WebSocketResponse中
- `payload`: 具体的业务数据，结构根据`interface`字段确定

### 客户端去服务器拉取消息（非分页）

```json
{
  "interface": "pullMessage",
  "version": 1,
  "payload": {
    "conversationId": XXXXX,
    "type": "text",// 就是消息类型
    "timestamp": 1695712222000,
    "serverMsgId": 236325  // 要拉取的信息的 serverMsgId
  }
}
```

### 客户端去服务器拉取消息（分页，用于云端漫游）

```json
{
  "interface": "pullMessageWithPagedQuery",
  "version": 1,
  "payload": {
    "conversationId": XXXXX,
    "type": "text",// 就是消息类型
    "timestamp": 1695712222000,
    "serverMsgId": 236325,        // 要拉取的信息的 serverMsgId
    "pageSize": 5,                // 一次拉取五条,从最后第五条往前拉取
    "pageIndex": 1                // 1代表倒数第一页
  }
}
```

### 发送消息（客户端→服务端）

文字消息示例：

```json
{
  "interface": "sendMessage",
  "version": 1,
  "payload": {
    "clientMsgId": "client_12344",
    "conversationId": XXXXX,
    "type": "text",// 就是消息类型
    "fromUserId": "customer_001",
    "timestamp": 1695712222000,
    "content": "你好，我想咨询一下产品信息",
    "uiState": "sending",
    "payload": null
  }
}
```

图片/视频类似，保留 `uiState: "sending"` 作为前端本地 UI 占位状态。

---

### 服务端响应 / 推送示例（统一 envelope）

#### 响应给客户端：当前消息发送结果

```json
{
  "interface": "rplySendResult",
  "version": 1,
  "success": true,
  "errorMessage": null,
  "payload": {
    "clientMsgId": "client_12344",
    "conversationId": XXXXX,
    "timestamp": 1695712222000,
    "serverMsgId": 236325,      // 客户写入服务端获取到的 serverMsgId，若未成功则为 null
    "uiState": "SENT"          // 前端应该展示的状态，SENT代表成功，FAILED代表失败
  }
}
```

#### 失败响应示例

```json
{
  "interface": "rplySendResult",
  "version": 1,
  "success": false,
  "errorMessage": "敏感词检测失败",
  "payload": {
    "clientMsgId": "client_12345",
    "conversationId": XXXXX,
    "timestamp": 1695712222000,
    "serverMsgId": null,
    "uiState": "FAILED"
  }
}
```

#### 推送给客户端：通知去拉取信息

```json
{
  "interface": "notifyPull",
  "version": 1,
  "success": true,
  "errorMessage": null,
  "payload": {
    "conversationId": XXXXX,
    "timestamp": 1695712222000,
    "serverMsgId": 236325,      // 客服回复生成的 serverMsgId
    "status": "PENDING"         // 该消息在服务端的状态，如果失败则为 FAILED
  }
}
```

#### 推送给客户端：更新为已读（后期实现，TODO）

```json
{
  "interface": "updateHasRead",
  "version": 1,
  "success": true,
  "errorMessage": null,
  "payload": {
    "clientMsgId": ["client_12344", "client_12345"],    // 可批量
    "conversationId": "conv_123456",
    "timestamp": 1695712222000,
    "serverMsgId": [236325, 236326],                     // 对应的服务端消息ID
    "status": "READ"                                     // 消息状态
  }
}
```

---

## 10. 实现要点

### 10.1 serverMsgId 生成（Redis + DB 备份）

* 正常：使用 Redis `INCR`（`chat:serverMsgId:{conversationId}`），性能高。
* Redis 重启或 key 不存在时：从 DB 查询该会话的最大 `server_msg_id`，初始化 Redis，防止重复。
* 初始化时使用分布式锁（Redisson）避免并发初始化竞态。

示例（伪 Java）：

```java
@Component
public class MessageIdGenerator {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @Autowired
    private ChatMessageService chatMessageService;
    
    public Long generateServerMsgId(String conversationId) {
        String key = "chat:serverMsgId:" + conversationId;
        
        // 检查 Redis 中是否存在
        if (!redisTemplate.hasKey(key)) {
            // 从数据库查询该对话窗口的最大 serverMsgId
            Long maxId = chatMessageService.getMaxServerMsgIdByConvId(conversationId);
            if (maxId != null) {
                // 设置为最大值，下次 increment 会从 maxId+1 开始
                redisTemplate.opsForValue().set(key, String.valueOf(maxId));
            }
        }
        
        return redisTemplate.opsForValue().increment(key);
    }
}
```

### 10.2 文件上传服务（概述）

```java
@Service
public class FileUploadService {
    
    @Autowired
    private MinioClient minioClient;
   
    public FileUploadResult uploadFile(MultipartFile file, String userId) {
        // 1. 文件类型和大小验证
        // 2. 病毒扫描
        // 3. 上传到 MinIO
        // 4. 返回文件 URL 和元数据
    }
}
```

---

## 11. 未读 / 已读 设计（服务端为权威）

* 服务端保存每个 `(conversation_id, user_id)` 的 `last_read_server_msg_id`（`user_conversation_read` 表），这是权威数据。
* 未读数可以按 `server_msg_id > last_read` 计算；但每次 DB COUNT 在高并发下可能慢，因此现实做法是 **DB 为真相 + Redis 缓存加速**。
* 推荐工程化做法：

### 核心设计原则

- **MySQL 作为事实库**：为每个 `(conversation_id, user_id)` 存一行 `last_read_server_msg_id`（这是权威数据）
- **前端保存本地 lastSeen，做即时展示**：浏览器收到 WS 通知就可以立刻用本地 lastSeen 更新未读显示（体验马上反馈）
- **服务端在消息入库时更新未读计数的缓存**：当 Processor 写入新消息后，同时（或通过可靠通知）增加该会话目标用户在缓存里的未读计数（例如 Redis 的 incr）
- **用户打开/滑动会话时调用服务端的 POST /read 接口**：服务端用事务把 `user_conversation_read.last_read_server_msg_id` 更新为客户端上报的最大值，并根据差值在缓存中原子扣减未读计数（或重建缓存）
- **定期用 DB 校验缓存（reconcile）**：有专门任务把 DB 的真实 last_read 与缓存对齐，修正误差

这样前端显示即时，服务端有权威，且能承受大流量。

### 具体实现方案

#### 数据库设计

在你已有的 MySQL 表里加 `user_conversation_read(conversation_id, user_id, last_read_server_msg_id)`（你已经有了这个想法，保持）。

#### 前端实现

**会话列表页**：
- 显示"未读数字"（Badge）时，调用 `GET /conversations?user=xxx`
- 服务端返回每个会话的 `last_message` 与 `unread_count`（从 cache 或 DB 计算）

**单聊页面**：
- 记录本地 `lastSeen`
- 收到 WS 的"去拉"通知则拉取并按序展示
- 用户滑动或进入会话时，前端上报 `POST /read {conversationId, lastSeenServerMsgId}`

#### 后端处理

**POST /read 接口**：
- 事务里读取 DB 的 `last_read_server_msg_id`
- 计算 delta，更新为新值
- 然后原子地更新缓存（减掉 delta）

**性能优化**：
- 若没有使用缓存，前端的 GET 会直接通过 DB COUNT 或用索引查 `server_msg_id > last_read`（性能受限）

**Processor（消息写入端）**：
- 写完 MySQL 后通知目标实例（你的 Redis Stream 收件箱）
- 并在同一流程里把缓存的未读计数加一（或让目标实例在投递时做这步）
- 以便会话列表能尽快显示未读

### 产品层面的说明

#### 前端没点开也能显示未读的常见做法

**会话列表的 Badge**（每个会话右上角的红点数字）：
- 通常来源于服务端返回的 `unread_count`（缓存加速）
- 或前端基于最后一条消息的 `server_msg_id` 和本地 `lastSeen` 做即时计算

**全局未读**（比如顶部的小铃铛）：
- 通常是对用户所有会话未读数的合计
- 服务端维持汇总值（缓存），避免每次都去 DB 做多个 COUNT

**"看但不算已读" 的区别**：
- 大多数应用区分 "已送达（delivered）" 和 "已读（read）"
- 只有当用户真正进入/滑动到消息或触发可视（visibility）条件时才上报 read，否则只是 delivered

**前端实现策略**：
- 可用 Visibility API（或 scroll/hover）判定用户是否"看见"消息
- 并据此决定是否上报 read
- 也可做"用户没有手动互动就不标为已读"的策略

**关于实现细节的一些坑（一定要注意）**

* 并发更新：多个设备同时上报 read，要用事务或乐观锁保证 last_read 不会回退。
* 原子扣减缓存：如果用 Redis 缓存未读数，read 接口应用 Lua 脚本或事务做原子减少，避免出现负数。
* 缓存和 DB 的一致性窗口：必须接受短暂不一致（几秒），并用定期 reconcile 修正。
* 深分页与计数代价：用 DB COUNT 去算未读在大表上可能很慢，必须用索引或缓存。
* 离线/多端同步：当用户在手机上把消息看了，电脑端也应在短时间内同步已读状态（通过 WS 或拉取），否则会出现不一致体验。


最小可运行清单：

* 保持 `user_conversation_read(conversation_id, user_id, last_read_server_msg_id)` 表。
* Processor 写消息时触发增加目标用户会话的未读计数缓存（可选）。
* 实现 `POST /read {conversationId, lastSeenServerMsgId}`：事务更新 DB 并原子更新缓存。
* 前端：收到 WS 通知立即拉取并本地更新 `lastSeen`；用户进入/滑动会话时上报 `read`。
* 定期对账任务（DB ↔ cache）。

总结一句话：用户没点开也能看到未读 —— 由客户端本地 `lastSeen` + 服务端权威 `last_read`（DB）结合实现；为性能采用缓存加速，两者结合既稳又快。

---

## 12. WebSocket 路由风格（Spring MVC 式，自定义注解示例）

WebSocket 没有内置和 Spring MVC 一样的注解路由风格时，你提出的做法是合适的：自定义注解 + 启动时注册 handler。

示例（注解与 handler）：

```java
// 自定义注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface WsInterface {
    String value();
}

// Handler(Controller) 示例
@Component
public class ChatWsController {
    @WsInterface("rplySendResult")
    public void rplySendResultHandler(Map<String,Object> payload, WebSocketSession session) {
        // 更新本地占位消息状态，发回 client 等
    }

    @WsInterface("notifyPull")
    public void notifyPullHandler(Map<String,Object> payload, WebSocketSession session) {
        // 通知客户端去拉增量
    }

    @WsInterface("updateHasRead")
    public void updateHasReadHandler(Map<String,Object> payload, WebSocketSession session) {
        // 更新前端已读显示
    }
}
```

前端（JS）处理示例：

```js
// WebSocket 收到消息后
ws.onmessage = (evt) => {
  const env = JSON.parse(evt.data);
  const iface = env.interface;
  const payload = env.payload || {};

  const router = {
    rplySendResult: handleRplySendResult,
    notifyPull: handleNotifyPull,
    updateHasRead: handleUpdateHasRead
  };

  const handler = router[iface];
  if (handler) handler(payload);
  else console.warn('Unknown interface', iface);
};

function handleRplySendResult(p) {
  // 用 clientMsgId 定位前端占位消息，若 serverMsgId != null 则合并/替换
  // 若 success/FAILED 则在 UI 做相应显示
}

function handleNotifyPull(p) {
  // p.serverMsgId 可作为拉取起点： GET /messages?conversationId=...&afterServerMsgId=localLastSeen
}

function handleUpdateHasRead(p) {
  // 更新会话已读指针、badge 等
}
```

好处：新增或删除接口只需新增/修改带注解的方法，类似 Spring MVC 的 controller 路由风格。

---

## 13. 额外注意的坑（摘录）

* 并发更新：多个设备同时上报 read，要用事务或乐观锁保证 `last_read` 不会回退。
* 原子扣减缓存：若用 Redis 缓存未读数，`/read` 接口应用 Lua 脚本或事务做原子减少，避免负数。
* 缓存与 DB 的一致性窗口：必须接受短暂不一致（几秒），并用定期 reconcile 修正。
* 深分页与计数代价：直接用 DB COUNT 计算未读在大表上可能很慢，需索引或缓存方案。
* 离线/多端同步：当用户在手机上把消息看了，电脑端也应在短时间内同步已读状态（通过 WS 或拉取），否则会出现不一致体验。

---

## 14. 高可用的建设


## 幂等与降级策略（Redis 优先，MySQL 兜底）

为提升可用性与一致性，新增两处降级策略：

- 幂等校验（步骤2之后、步骤3之前执行）
  - 正常：使用 Redis 键 `chat:idemp:{conversationId}:{clientMsgId}` 做幂等。第一次 `SETNX=PENDING` 占位，入库成功后把值更新为此次 `server_msg_id`（可设置 TTL）。若重复请求命中且值为数字，直接返回对应 `server_msg_id`。
  - 降级：若 Redis 不可用，则回退到 MySQL，按唯一键 `(conversation_id, client_msg_id)` 查询已有记录，命中则返回其中的 `server_msg_id`。

- serverMsgId 分配
  - 正常：Redis `INCR chat:serverMsgId:{conversationId}`；首次使用 Redisson 分布式锁做懒初始化（从 MySQL 查 `MAX(server_msg_id)` 写回 Redis 再 `INCR`）。
  - 降级：若 Redis/锁异常，则返回 `redisAvailable=false` 并使用 `DB MAX(server_msg_id) + 1` 作为本次 `server_msg_id`（允许出现跳号）。

- 入库策略
  - 正常：常规 `INSERT`（保留幂等保证）。
  - 降级：使用 MySQL 能力自增 `server_msg_id`，即 `INSERT ... ON DUPLICATE KEY UPDATE server_msg_id = server_msg_id + 1`，牺牲幂等性；随后再按 `(conversation_id, client_msg_id)` 查询确认最终 `server_msg_id`。

代码要点：
- `IdempotencyService`：封装幂等校验与降级（Redis 优先，失败回退 MySQL），并提供 `markSuccess` 更新幂等键。
- `MessageIdGenerator.generateServerMsgId`：仅以 try/catch 包裹 Redis/Redisson 操作，失败即降级为 `DB MAX + 1`，返回 `MessageIdGenerateResult{redisAvailable, serverMsgId}`。
- `ChatMessageMapper`：新增 `insertOneOnDupIncr`/注解 `insertOneOnDupIncrAnno` 支持 ON DUPLICATE 自增；保留 `selectByConvIdAndClientMsgId` 供降级与幂等回查使用。

---

## 15. 整体方案高可用分析
    客户端托底（WS 心跳 + TTL 懒回收 + 轻通知 + 懒初始化）

## 16. 可插拔服务器间通信协议设计

### 16.1 设计理念

**核心原则：**
- **框架无关**：不依赖Spring WebSocket等特定框架，使用Java标准库
- **业务无感知**：业务层完全不需要知道底层通信协议实现
- **可插拔**：支持多种通信协议，可根据需要切换
- **通用性**：框架层可以独立维护，给其他项目使用

**架构优势：**
- 业务开发人员专注于业务逻辑，不需要关心分布式通信细节
- 框架层可以独立升级和维护
- 支持协议性能对比和选择
- 便于测试和调试

### 16.2 协议接口设计

```java
public interface ServerCommProtocol {
    // 发送消息到目标实例
    CompletableFuture<Boolean> sendMessage(String targetInstanceAddress, Object message);
    
    // 协议生命周期管理
    void initialize();
    void shutdown();
    boolean isHealthy();
    
    // 协议信息
    String getProtocolName();
    boolean supportsTarget(String targetInstanceAddress);
}
```

### 16.3 支持的协议

#### WebSocket协议
- **特点**：使用Java标准库WebSocket客户端，不依赖Spring WebSocket
- **优势**：长连接复用，延迟更低，适合实时通信
- **适用场景**：对实时性要求高的聊天系统
- **配置**：`server.comm.protocol=websocket`

#### HTTP/2协议
- **特点**：使用Java标准库HTTP/2客户端
- **优势**：更好的网络兼容性，防火墙友好，监控工具完善
- **适用场景**：对网络兼容性要求高的环境
- **配置**：`server.comm.protocol=http2`
- **实现**：`Http2ServerCommProtocol` + `Http2ServerCommController`（框架层controller包）

### 16.4 协议管理器

```java
@Component
public class ServerCommProtocolManager {
    // 根据配置自动选择协议
    // 提供统一的通信接口
    // 支持协议健康检查
}
```

### 16.5 配置示例

```yaml
websocket:
  # 实例配置
  instance:
    ip: 192.168.8.109  # 显式指定本机实例IP
    port: 8086          # 显式指定本机实例端口
  
  # 分布式配置
  distributed:
    enabled: true                    # 是否启用分布式功能
    # 服务器间通信协议配置（可插拔设计）
    server-comm:
      enabled: true                  # 是否启用服务器间通信
      protocol: websocket            # 通信协议：websocket 或 http2
      websocket:
        handshake-timeout: 5000      # WebSocket握手超时时间（毫秒）
        heartbeat-interval: 30000   # 心跳间隔（毫秒）
        heartbeat-timeout: 10000    # 心跳超时（毫秒）
        retry: 3                     # 最大重试次数
      http2:
        connect-timeout: 3000       # HTTP/2连接超时时间（毫秒）
        request-timeout: 5000       # HTTP/2请求超时时间（毫秒）
        retry: 5                     # 最大重试次数
        endpoint: /server/push      # HTTP/2推送端点
    
    # 通知重试配置
    notification-retry:
      enabled: true                  # 是否启用通知重试
      max-retries: 10               # 最大重试次数
      retry-interval: 1000          # 重试间隔（毫秒）
      max-retry-interval: 30000    # 最大重试间隔（毫秒）
      backoff-multiplier: 2.0      # 退避乘数
      infinite-retry: true          # 是否无限重试
      session-change-retry: true    # 会话变化时是否重试
```

**配置说明：**

- **WebSocket协议配置**：
  - `handshake-timeout`：建立WebSocket连接时的握手超时时间
  - `heartbeat-interval`：心跳检测的间隔时间，用于保持连接活跃
  - `heartbeat-timeout`：心跳检测的超时时间，超时则认为连接断开
  - `retry`：连接失败时的最大重试次数

- **HTTP/2协议配置**：
  - `connect-timeout`：建立TCP连接的超时时间
  - `request-timeout`：发送HTTP请求的超时时间
  - `retry`：请求失败时的最大重试次数
  - `endpoint`：接收推送消息的HTTP端点路径

### 16.6 业务层使用

**业务层完全无感知：**
```java
// 业务层只需要调用统一的推送服务
@Autowired
private ServerCommProtocolManager protocolManager;

// 发送消息（框架层自动选择协议和实例）
protocolManager.sendMessage(targetInstanceAddress, message);
```

**框架层自动处理：**
- 自动判断目标实例是否为自己（避免自己连接自己）
- 自动选择配置的通信协议
- 自动处理连接管理和重试
- 自动处理错误和异常

### 16.7 扩展性

**添加新协议：**
1. 实现 `ServerCommProtocol` 接口
2. 添加 `@Component` 注解
3. 在配置文件中添加新协议选项
4. 重启应用即可使用新协议

**协议切换：**
- 修改配置文件中的 `server.comm.protocol` 值
- 重启应用即可切换到新协议
- 无需修改任何业务代码

### 16.8 监控和调试

**协议健康检查：**
- 每个协议都提供 `isHealthy()` 方法
- 协议管理器提供统一的健康检查接口
- 支持协议级别的监控和告警

### 16.9 事务管理

**消息接收事务**：
- `CustomerChatService.receiveMessage()` 和 `AgentServiceChatService.receiveMessage()` 都使用 `@Transactional(rollbackFor = Exception.class)`
- 确保消息处理的原子性：数据库插入、幂等性标记、会话状态更新等操作要么全部成功，要么全部回滚
- 避免异常时数据不一致导致客户重发消息

**事务边界优化**：
- 核心事务只包含：消息验证 → 幂等性检查 → 生成serverMsgId → 数据库插入 → 幂等性标记
- 会话创建和客服分配移出事务，改为异步处理
- 大幅减少事务时间，降低锁冲突概率

**异步处理**：
- `handleConversationAsync()` 异步处理会话状态和分配逻辑
- 避免会话创建和客服分配影响消息处理性能
- 即使会话处理失败，消息已成功保存，不影响用户体验

### 15.1 Redis/Nacos 职责边界

- Redis：
  - `ws:session:{sessionId} -> instanceId`，带 TTL（默认 300s）。仅由 WebSocket 事件续期（握手、任意消息、ping/pong）。onClose 可达则 DEL；异常断链靠 TTL 懒回收。
  - `chat:serverMsgId:{conversationId} -> latestServerMsgId`，无 TTL，作为会话内最新序号缓存，生成采用懒初始化 + INCR。
  - `user:instance:{userId}`：用户-实例映射，支持基于userId的推送。
- Nacos：仅用于判断实例是否在线（活跃实例列表）。不参与会话在线判断。推送前做“惰性校验”：`GET ws:session:*` 存在且 instance 仍活跃，否则跳过。

注：若 mall-chat 实例临时连不上 Nacos，但 WS 正常、Redis 正常，系统仍可工作；实例恢复或重启后不影响会话 TTL 与消息流转。

### 15.2 基于WebSocket重发的推送机制

#### 15.2.1 推送架构

**推送方式**：
- 通过服务器间 WebSocket 连接直接推送
- 优势：实时推送，支持重试机制
- 消费：客户端重连后主动拉取离线消息

#### 15.2.2 推送流程

1. **消息推送**：
   ```java
   // 推送给用户（支持重试）
   notificationDispatcher.dispatchByUserId(userId, conversationId, serverMsgId);
   ```

2. **服务器间通信**：
   ```java
   // 通过 WebSocket 连接池推送
   serverWebSocketPool.sendMessage(targetInstanceId, message);
   ```

3. **重试机制**：
   ```java
   // 支持 Nacos 配置的重试策略
   retryManager.executeWithRetry(userId, message, targetInstanceId);
   ```

#### 15.2.3 重试策略

- **Nacos 配置**：支持动态配置重试次数、间隔、退避策略
- **sessionId 变化重试**：自动检测用户重连后的 sessionId 变化
- **无限重试**：可配置是否无限重试
- **告警机制**：重试失败时自动告警到企业微信，支持推送失败和系统异常两种告警类型

### 15.3 会话在线与 TTL 懒回收

- 注册：`afterConnectionEstablished` 写入 `ws:session:{sessionId}`，TTL=300s。
- 续期：收到任意 WS 帧（含 ping/pong/业务）调用 `EXPIRE ws:session:{sessionId} 300`。
- 注销：`afterConnectionClosed` 删除键。
- 异常场景（断网/宕机/onClose 未触达）：不再续期，TTL 到期自动过期，实现懒回收。

### 15.3 serverMsgId 生成（允许空洞，懒初始化）

- Key：`chat:serverMsgId:{conversationId}`。
- 流程：
  1) 快路径：`INCR`（若 key 存在）。
  2) 慢路径：key 不存在 → Redisson 分布式锁 → 查 DB `MAX(server_msg_id)` → `SET key=maxOr0` → `INCR`。
- 只读探测：提供 `probeLatestServerMsgId(conversationId)`，顺序为 Redis → MySQL，返回“当前已知最大”值（不存在返回 0），不做任何写入或加锁。

### 15.4 轻通知与客户端拉取

- 发送侧把最小载荷推送到目标实例：`{conversationId, serverMsgId}`。
- 目标实例接收后，面向客户端推送标准 `notifyPull`：
```json
{
  "interface": "notifyPull",
  "version": 1,
  "success": true,
  "errorMessage": null,
  "payload": {
    "conversationId": "XXXXX",
    "timestamp": 1695712222000,
    "serverMsgId": 236325,
    "status": "PENDING"
  }
}
```
- 客户端据此调用拉取接口（按 `lastSeenServerMsgId` 拉增量），MySQL 为真相库。

### 15.5 WebSocket 心跳（探活 + 兜底对账）

- 客户端周期发送 WS 心跳，载荷可批量带 `{conversationId, clientMaxServerMsgId}`：
  - 服务端：
    - 续期 `ws:session:{sessionId}` 的 TTL（300s）。
    - 逐会话比对 `chat:serverMsgId:{conversationId}`（Redis，不在时按 15.3 懒初始化或降级查 DB）：
      - 若 `redisMax > clientMax` → 返回 `needPull=true, latestServerMsgId=redisMax, pullFrom=clientMax+1`；
      - 否则 `needPull=false`。
- 该心跳不引入 HTTP；HTTP 不具备 WS 会话语义。心跳暂定60s,本身redis和nacos都是集群运行,出问题的概率很小,而且,都出问题还有客户端心跳兜底
(如果nacos整体崩溃,未显性配置的话,网关默认30s内还可以根据久的缓存调用mall-chat),如果nacos不是集体崩溃,就还好,至于nacos完全崩溃,那时候你就不会关心客服系统了

### 15.6 推送前惰性校验

推送至某 `sessionId` 前：
1) `GET ws:session:{sessionId}` → 无则放弃推送（客户端靠心跳/拉取兜底）。
2) 读得 `instanceId` 后，校验该实例在 Nacos 活跃集内；不活跃则放弃推送（或可选惰性清理该键）,反正有客户端心跳兜底,心跳里会查询有没有新消息。

### 15.7 降级与可用性

- ID 生成：Redis/锁异常 → 返回 `DB MAX + 1`（允许跳号）。
- 探测最大值：`probeLatestServerMsgId` Redis 失败 → 查 DB；都无 → 0。
- 会话在线：完全由 WS 心跳 + TTL 决定；Nacos 仅用于实例级在线。
### 15.8 mall-chat实例的重启或宕机
如果是正常的重启,websocket连接关闭前会调用onclose,我们在那里做了清理redis的操作,因此,优雅停机这些都没有问题,如果是宕机,那只能依赖客户端的心跳了,客户端的心跳是客户
进入聊天,发起聊天才会触发心跳的维持,然后整个使用app或者网页期间,心跳都是存在的,直到客户关闭app,这样客户可以在等客服人员回复期间逛商城或者做别的
### 15.9 会话状态管理（软删除）

**会话状态定义**：
- `active` - 正常活跃会话
- `waiting` - 等待客服响应  
- `closed` - 客服关闭
- `deleted_by_customer` - 客户主动删除/隐藏
- `deleted_by_agent` - 客服删除/归档

**软删除机制**：
- **客户删除会话**：`AgentRoutingService.deleteConversationByCustomer(conversationId, customerId)`
  - 设置会话状态为 `deleted_by_customer`
  - 客户重新上线不再显示该会话
- **客服删除会话**：`AgentRoutingService.deleteConversationByAgent(conversationId, agentId)`  
  - 设置会话状态为 `deleted_by_agent`
  - 所有客服成员设置为离开状态
  - 禁用该会话的消息路由

**路由层过滤**：
- `AgentRoutingService.routeForConversation()` 自动排除状态为 `deleted_by_customer` 或 `deleted_by_agent` 的会话
- 确保软删除的会话不会被重新激活或接收新消息

### 15.10 各种异常分析
跟nacos的连接状态,跟redis的连接状态,跟客户端的连接状态都有可能出现问题,不管是网络问题还是宕机,比如如果突然宕机的话,客户端如果不主动发送心跳,是不会知道服务器宕机的,
这里的想法是,跟nacos和redis的连接状态,是可以靠后台的自身监控来完成的,不需要这里再设计复杂的高可用方案了,只要mysql和客户端的心跳这两个能正常运行,nacos(需要微服务缓存实例的ip,不要让
微服务连不上nacos就立刻清理,保留微服务本地的实例ip列表的缓存,这样nacos宕机也能运行)和redis哪怕无法
工作都是可以正常运行的,只不过会非常慢,只能依靠心跳来拉取了,这时候就会很慢

### 15.11 可能的并发问题

**问题描述**：
客户端拉取消息时可能存在并发问题：兜底心跳刚触发，然后有新消息要拉取的推送就随后抵达客户端，然后客户端去拉取的时候，可能会和兜底的存在并发问题。

**具体场景**：
1. 客户端发送心跳请求，触发拉取请求A
2. 服务器立即推送新消息通知到客户端
3. 客户端收到推送，再次触发拉取请求B
4. 拉取请求A和拉取请求B并发执行，可能导致消息重复显示

**解决方案**：
消息显示在聊天窗口里需要去重，即需要检查每条消息的`clientMsgId`是否已经显示在聊天窗口了。

**客户端实现建议**：
```javascript
// 聊天窗口维护一个已显示消息的ID集合
const displayedMessageIds = new Set();

// 接收到拉取的消息时，过滤掉已显示的消息
function handlePullMessages(messages) {
    const newMessages = messages.filter(msg => !displayedMessageIds.has(msg.clientMsgId));
    
    // 显示新消息
    newMessages.forEach(msg => {
        displayMessage(msg);
        displayedMessageIds.add(msg.clientMsgId);
    });
}

// 清理过期消息ID（避免Set无限增长）
setInterval(() => {
    // 保留最近1000条消息的ID
    if (displayedMessageIds.size > 1000) {
        // 清理策略...
    }
}, 60000);
```

**关键点**：
- 使用`clientMsgId`作为唯一标识进行去重
- 客户端维护已显示消息的ID记录
- 定期清理过期的消息ID记录
- 确保消息的顺序性不受去重影响
